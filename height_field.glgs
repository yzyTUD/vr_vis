#version 150

//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************


uniform int nr_quads_per_row;
uniform sampler2D depth_base_tex;
uniform sampler2D depth_tex;

uniform float texel_extent;
uniform float quad_extent;
uniform vec4 transform;

in int instanceIn[];
in vec4 colorIn[];
in vec2 texcoord_gs[];

out vec3 position_eye;
out vec3 normal_eye;
out vec4 color;
out vec2 texcoord_fs;

vec2 min_tcd;
vec2 max_tcd;

float get_z(in vec2 tcd)
{
	//if(tcd.x<texel_extent * (float(10) + 0.5))
		//return 2.0 * ( texture(depth_base_tex, tcd).r ) - 1.0;
		// texture(depth_base_tex, tcd).r + texture(depth_tex, tcd).r;

	return tcd.x * tcd.x - tcd.y * tcd.y;
		//(tcd.x - 0.5) * (tcd.x - 0.5) + (tcd.y - 0.5) * (tcd.y - 0.5);
		//1 - (tcd.x - 0.5) * (tcd.x - 0.5) - (tcd.y - 0.5) * (tcd.y - 0.5);
		//tcd.x * tcd.x + tcd.y * tcd.y;
		//
}

vec3 compute_normal(in vec2 tcd)
{
	/* task 1.5c begin */
	vec2 xminus_y = vec2(tcd.x-texel_extent,tcd.y);
	vec2 xplus_y = vec2(tcd.x+texel_extent,tcd.y);
	vec2 x_yminus = vec2(tcd.x,tcd.y-texel_extent);
	vec2 x_yplus = vec2(tcd.x,tcd.y+texel_extent);

	float dzdx = get_z(xminus_y) - get_z(xplus_y);
	float dzdy = get_z(x_yminus) - get_z(x_yplus);

	return normalize(get_normal_matrix() * vec3(dzdx,2.0f*quad_extent,dzdy));
	/* task 1.5c end */
}

void generate_vertex(in vec2 p2d, in vec2 tcd)
{
	vec4  vertex = vec4(p2d.x, get_z(tcd), p2d.y, 1.0) + transform;
	vec4  hposition_eye = get_modelview_matrix()*vertex;
	position_eye = hposition_eye.xyz / hposition_eye.w;
	normal_eye   = compute_normal(tcd);
	gl_Position  = get_modelview_projection_matrix()*vertex; 
	EmitVertex();
}

void main()
{
	int i = instanceIn[0] % nr_quads_per_row;
	int j = instanceIn[0] / nr_quads_per_row;
	//colorIn[0];
	texcoord_fs = min_tcd;

	// compute quad corners in texture space
	min_tcd = texel_extent * vec2(float(i), float(j)) - vec2(0.5);
	max_tcd = min_tcd + vec2(texel_extent);

	// compute quad corners in xy-plane
	vec2 ctr_p2D = quad_extent * vec2(float(i), float(j)) - vec2(0.5);
	vec2 min_p2D = ctr_p2D;
	vec2 max_p2D = ctr_p2D + vec2(quad_extent);

	color = vec4(
				float(i)/nr_quads_per_row,
				float(j)/nr_quads_per_row,
				1-float(i)/nr_quads_per_row,
			1);

	// generate quad
	generate_vertex(min_p2D, min_tcd);
	generate_vertex(vec2(max_p2D.x,min_p2D.y), vec2(max_tcd.x, min_tcd.y));
	generate_vertex(vec2(min_p2D.x,max_p2D.y), vec2(min_tcd.x, max_tcd.y));
	generate_vertex(max_p2D, max_tcd);
	EndPrimitive(); 
}
